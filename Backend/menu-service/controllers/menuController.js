const MenuItem = require("../models/MenuItem");
const {
  deleteCloudinaryFile,
  getThumbnailUrl,
} = require("../config/cloudinary");

// Helper function ƒë·ªÉ x√≥a file ·∫£nh t·ª´ Cloudinary
const deleteImageFile = async (imagePath) => {
  if (!imagePath) return false;

  // Ch·ªâ x·ª≠ l√Ω Cloudinary URLs
  if (imagePath.includes("cloudinary.com")) {
    return await deleteCloudinaryFile(imagePath);
  }

  return false;
};

exports.getAllMenuItems = async (req, res) => {
  try {
    const items = await MenuItem.find();
    // Th√™m th√¥ng tin h√¨nh ·∫£nh v√†o response
    const itemsWithImageInfo = items.map((item) => ({
      ...item.toObject(),
      hasImage: !!item.image,
      imageUrl: item.image,
    }));
    res.json(itemsWithImageInfo);
  } catch (err) {
    res.status(500).json({ message: "Server error", error: err.message });
  }
};

exports.createMenuItem = async (req, res) => {
  try {
    // X·ª≠ l√Ω d·ªØ li·ªáu t·ª´ form-data ho·∫∑c JSON
    const itemData = { ...req.body };

    // Parse d·ªØ li·ªáu t·ª´ form-data (n·∫øu c·∫ßn)
    if (
      req.file ||
      req.headers["content-type"]?.includes("multipart/form-data")
    ) {
      // Form-data g·ª≠i t·∫•t c·∫£ l√† string, c·∫ßn parse
      if (itemData.price) itemData.price = parseFloat(itemData.price);
      if (itemData.available !== undefined) {
        itemData.available =
          itemData.available === "true" || itemData.available === true;
      }
      // Parse ingredients t·ª´ JSON string
      if (itemData.ingredients && typeof itemData.ingredients === "string") {
        try {
          itemData.ingredients = JSON.parse(itemData.ingredients);
        } catch (e) {
          console.warn("Failed to parse ingredients:", e);
          itemData.ingredients = [];
        }
      }
    }

    // X·ª≠ l√Ω file upload n·∫øu c√≥
    if (req.file) {
      // Cloudinary upload - multer-storage-cloudinary t·ª± ƒë·ªông upload v√† tr·∫£ v·ªÅ URL
      itemData.image = req.file.path; // Cloudinary URL
      console.log(`üìÅ File uploaded to Cloudinary: ${req.file.filename}`);
    }

    // N·∫øu c√≥ h√¨nh ·∫£nh t·ª´ URL (kh√¥ng ph·∫£i file upload), validate format
    if (itemData.image && !req.file) {
      // Ch·ªâ ch·∫•p nh·∫≠n HTTP/HTTPS URLs
      if (!/^https?:\/\//.test(itemData.image)) {
        return res.status(400).json({
          message: "Invalid image format",
          error: "Image must be a valid HTTP/HTTPS URL",
        });
      }
    }

    // T·ª± ƒë·ªông t·∫°o imageAlt n·∫øu kh√¥ng c√≥
    if (!itemData.imageAlt && itemData.name) {
      itemData.imageAlt = `${itemData.name} image`;
    }

    const newItem = new MenuItem(itemData);
    await newItem.save();

    // Th√™m th√¥ng tin h√¨nh ·∫£nh v√†o response
    const responseItem = {
      ...newItem.toObject(),
      hasImage: !!newItem.image,
      imageUrl: newItem.image,
      thumbnailUrl: newItem.image ? getThumbnailUrl(req.file?.filename) : null,
      uploadedFile: req.file
        ? {
            originalName: req.file.originalname,
            filename: req.file.filename, // Cloudinary public_id
            path: req.file.path, // Cloudinary URL
            size: req.file.size,
          }
        : null,
    };

    res.status(201).json(responseItem);
  } catch (err) {
    // Log l·ªói chi ti·∫øt ƒë·ªÉ debug
    console.error("‚ùå Create menu item error:", {
      message: err.message,
      stack: err.stack,
      name: err.name,
      code: err.code,
    });

    // X√≥a file Cloudinary ƒë√£ upload n·∫øu c√≥ l·ªói
    if (req.file && req.file.filename) {
      try {
        await deleteCloudinaryFile(req.file.filename);
        console.log(
          `üóëÔ∏è Deleted failed Cloudinary upload: ${req.file.filename}`
        );
      } catch (deleteError) {
        console.error("‚ùå Error deleting failed upload:", deleteError.message);
      }
    }

    res.status(500).json({
      message: "Create failed",
      error: err.message || "Unknown error",
      details: process.env.NODE_ENV === "development" ? err.stack : undefined,
    });
  }
};

exports.updateMenuItem = async (req, res) => {
  try {
    const updateData = { ...req.body };

    // Parse ingredients t·ª´ JSON string n·∫øu c·∫ßn
    if (updateData.ingredients && typeof updateData.ingredients === "string") {
      try {
        updateData.ingredients = JSON.parse(updateData.ingredients);
      } catch (e) {
        console.warn("Failed to parse ingredients:", e);
        updateData.ingredients = [];
      }
    }

    // L·∫•y th√¥ng tin m√≥n ƒÉn hi·ªán t·∫°i ƒë·ªÉ check ·∫£nh c≈©
    const existingItem = await MenuItem.findById(req.params.id);
    if (!existingItem) {
      return res.status(404).json({ message: "Item not found" });
    }

    // X·ª≠ l√Ω file upload m·ªõi (n·∫øu c√≥)
    if (req.file) {
      // X√≥a ·∫£nh c≈© n·∫øu c√≥
      if (existingItem.image) {
        await deleteImageFile(existingItem.image);
      }
      // ƒê·∫∑t ·∫£nh m·ªõi t·ª´ Cloudinary
      updateData.image = req.file.path; // Cloudinary URL
    } else if (updateData.image) {
      // N·∫øu c·∫≠p nh·∫≠t b·∫±ng URL m·ªõi v√† kh√°c ·∫£nh c≈©
      if (updateData.image !== existingItem.image) {
        // X√≥a ·∫£nh c≈© n·∫øu l√† file upload
        await deleteImageFile(existingItem.image);
      }

      // Validate URL format - ch·ªâ ch·∫•p nh·∫≠n HTTP/HTTPS
      if (!/^https?:\/\//.test(updateData.image)) {
        return res.status(400).json({
          message: "Invalid image format",
          error: "Image must be a valid HTTP/HTTPS URL",
        });
      }
    }

    // C·∫≠p nh·∫≠t imageAlt n·∫øu c√≥ thay ƒë·ªïi name
    if (updateData.name && !updateData.imageAlt) {
      updateData.imageAlt = `${updateData.name} image`;
    }

    const updated = await MenuItem.findByIdAndUpdate(
      req.params.id,
      updateData,
      { new: true }
    );

    // Th√™m th√¥ng tin h√¨nh ·∫£nh v√†o response
    const responseItem = {
      ...updated.toObject(),
      hasImage: !!updated.image,
      imageUrl: updated.image,
      thumbnailUrl: updated.image ? getThumbnailUrl(req.file?.filename) : null,
      uploadedFile: req.file
        ? {
            originalName: req.file.originalname,
            filename: req.file.filename,
            path: req.file.path,
            size: req.file.size,
          }
        : null,
    };

    res.json(responseItem);
  } catch (err) {
    // Log l·ªói chi ti·∫øt
    console.error("‚ùå Update menu item error:", {
      message: err.message,
      stack: err.stack,
      name: err.name,
    });

    // X√≥a file Cloudinary m·ªõi upload n·∫øu c√≥ l·ªói
    if (req.file && req.file.filename) {
      try {
        await deleteCloudinaryFile(req.file.filename);
        console.log(
          `üóëÔ∏è Deleted failed Cloudinary upload: ${req.file.filename}`
        );
      } catch (deleteError) {
        console.error("‚ùå Error deleting failed upload:", deleteError.message);
      }
    }

    res.status(500).json({
      message: "Update failed",
      error: err.message || "Unknown error",
      details: process.env.NODE_ENV === "development" ? err.stack : undefined,
    });
  }
};

exports.deleteMenuItem = async (req, res) => {
  try {
    // T√¨m m√≥n ƒÉn tr∆∞·ªõc khi x√≥a ƒë·ªÉ l·∫•y th√¥ng tin ·∫£nh
    const itemToDelete = await MenuItem.findById(req.params.id);
    if (!itemToDelete) {
      return res.status(404).json({ message: "Item not found" });
    }

    // X√≥a file ·∫£nh n·∫øu c√≥
    if (itemToDelete.image) {
      const deleted = await deleteImageFile(itemToDelete.image);
      console.log(`üóëÔ∏è Image deletion result: ${deleted}`);
    }

    // X√≥a m√≥n ƒÉn kh·ªèi database
    const deleted = await MenuItem.findByIdAndDelete(req.params.id);

    res.json({
      message: "Deleted successfully",
      deletedItem: {
        id: deleted._id,
        name: deleted.name,
        hadImage: !!deleted.image,
        imageDeleted: !!deleted.image,
      },
    });
  } catch (err) {
    res.status(400).json({ message: "Delete failed", error: err.message });
  }
};
exports.getMenuItemById = async (req, res) => {
  try {
    const item = await MenuItem.findById(req.params.id);
    if (!item)
      return res.status(404).json({ message: "Kh√¥ng t√¨m th·∫•y m√≥n ƒÉn" });

    // Th√™m th√¥ng tin h√¨nh ·∫£nh v√†o response
    const responseItem = {
      ...item.toObject(),
      hasImage: !!item.image,
      imageUrl: item.image,
    };

    res.json(responseItem);
  } catch (err) {
    res.status(400).json({ message: "L·ªói khi l·∫•y m√≥n ƒÉn", error: err.message });
  }
};

// API ri√™ng ƒë·ªÉ c·∫≠p nh·∫≠t h√¨nh ·∫£nh
exports.updateMenuItemImage = async (req, res) => {
  try {
    const { image, imageAlt } = req.body;

    if (!image) {
      return res.status(400).json({ message: "Image URL is required" });
    }

    // Validate image format
    if (!/^(https?:\/\/|\/|[a-zA-Z]:\\)/.test(image)) {
      return res.status(400).json({
        message: "Invalid image format",
        error: "Image must be a valid URL or file path",
      });
    }

    // L·∫•y th√¥ng tin m√≥n ƒÉn hi·ªán t·∫°i
    const existingItem = await MenuItem.findById(req.params.id);
    if (!existingItem) {
      return res.status(404).json({ message: "Item not found" });
    }

    // X√≥a ·∫£nh c≈© n·∫øu c√≥ v√† kh√°c ·∫£nh m·ªõi
    if (existingItem.image && existingItem.image !== image) {
      deleteImageFile(existingItem.image);
    }

    const updateData = { image };
    if (imageAlt) updateData.imageAlt = imageAlt;

    const updated = await MenuItem.findByIdAndUpdate(
      req.params.id,
      updateData,
      { new: true }
    );

    res.json({
      message: "Image updated successfully",
      oldImageDeleted: existingItem.image && existingItem.image !== image,
      item: {
        ...updated.toObject(),
        hasImage: !!updated.image,
        imageUrl: updated.image,
      },
    });
  } catch (err) {
    res
      .status(400)
      .json({ message: "Image update failed", error: err.message });
  }
};

// API ƒë·ªÉ x√≥a h√¨nh ·∫£nh
exports.removeMenuItemImage = async (req, res) => {
  try {
    // T√¨m m√≥n ƒÉn ƒë·ªÉ l·∫•y th√¥ng tin ·∫£nh tr∆∞·ªõc khi x√≥a
    const existingItem = await MenuItem.findById(req.params.id);
    if (!existingItem) {
      return res.status(404).json({ message: "Item not found" });
    }

    // X√≥a file ·∫£nh n·∫øu c√≥
    const imageDeleted = deleteImageFile(existingItem.image);

    // X√≥a th√¥ng tin ·∫£nh kh·ªèi database
    const updated = await MenuItem.findByIdAndUpdate(
      req.params.id,
      { $unset: { image: 1, imageAlt: 1 } },
      { new: true }
    );

    res.json({
      message: "Image removed successfully",
      imageFileDeleted: imageDeleted,
      item: {
        ...updated.toObject(),
        hasImage: false,
        imageUrl: null,
      },
    });
  } catch (err) {
    res
      .status(400)
      .json({ message: "Image removal failed", error: err.message });
  }
};

// API ƒë·ªÉ l·∫•y t·∫•t c·∫£ m√≥n ƒÉn c√≥ h√¨nh ·∫£nh
exports.getMenuItemsWithImages = async (req, res) => {
  try {
    const items = await MenuItem.find({ image: { $exists: true, $ne: null } });
    const itemsWithImageInfo = items.map((item) => ({
      ...item.toObject(),
      hasImage: true,
      imageUrl: item.image,
    }));
    res.json(itemsWithImageInfo);
  } catch (err) {
    res.status(500).json({ message: "Server error", error: err.message });
  }
};

// API ƒë·ªÉ l·∫•y t·∫•t c·∫£ m√≥n ƒÉn kh√¥ng c√≥ h√¨nh ·∫£nh
exports.getMenuItemsWithoutImages = async (req, res) => {
  try {
    const items = await MenuItem.find({
      $or: [{ image: { $exists: false } }, { image: null }, { image: "" }],
    });
    const itemsWithImageInfo = items.map((item) => ({
      ...item.toObject(),
      hasImage: false,
      imageUrl: null,
    }));
    res.json(itemsWithImageInfo);
  } catch (err) {
    res.status(500).json({ message: "Server error", error: err.message });
  }
};

// API ƒë·ªÉ upload file h√¨nh ·∫£nh ri√™ng
exports.uploadImageOnly = async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ message: "No image file provided" });
    }

    const imageUrl = `/uploads/${req.file.filename}`;

    res.status(201).json({
      message: "Image uploaded successfully",
      imageUrl: imageUrl,
      file: {
        originalName: req.file.originalname,
        filename: req.file.filename,
        size: req.file.size,
        mimetype: req.file.mimetype,
      },
    });
  } catch (err) {
    // X√≥a file ƒë√£ upload n·∫øu c√≥ l·ªói
    if (req.file) {
      const filePath = path.join(__dirname, "../uploads", req.file.filename);
      if (fs.existsSync(filePath)) {
        fs.unlinkSync(filePath);
      }
    }
    res.status(400).json({ message: "Upload failed", error: err.message });
  }
};

// API ƒë·ªÉ t·∫°o menu v·ªõi file upload
exports.createMenuItemWithUpload = async (req, res) => {
  try {
    // X·ª≠ l√Ω d·ªØ li·ªáu t·ª´ form-data
    const itemData = { ...req.body };

    // Parse s·ªë t·ª´ string (form-data g·ª≠i t·∫•t c·∫£ l√† string)
    if (itemData.price) itemData.price = parseFloat(itemData.price);
    if (itemData.available) itemData.available = itemData.available === "true";

    // X·ª≠ l√Ω file upload
    if (req.file) {
      const imageUrl = `/uploads/${req.file.filename}`;
      itemData.image = imageUrl;
    }

    // T·ª± ƒë·ªông t·∫°o imageAlt n·∫øu kh√¥ng c√≥
    if (!itemData.imageAlt && itemData.name) {
      itemData.imageAlt = `${itemData.name} image`;
    }

    const newItem = new MenuItem(itemData);
    await newItem.save();

    // Th√™m th√¥ng tin h√¨nh ·∫£nh v√†o response
    const responseItem = {
      ...newItem.toObject(),
      hasImage: !!newItem.image,
      imageUrl: newItem.image,
      uploadedFile: req.file
        ? {
            originalName: req.file.originalname,
            filename: req.file.filename,
            size: req.file.size,
          }
        : null,
    };

    res.status(201).json(responseItem);
  } catch (err) {
    // X√≥a file ƒë√£ upload n·∫øu c√≥ l·ªói
    if (req.file) {
      const filePath = path.join(__dirname, "../uploads", req.file.filename);
      if (fs.existsSync(filePath)) {
        fs.unlinkSync(filePath);
      }
    }
    res
      .status(400)
      .json({ message: "Create with upload failed", error: err.message });
  }
};
