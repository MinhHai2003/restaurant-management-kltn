export interface AIResponse {
  text: string;
  confidence?: number;
  source?: 'groq' | 'openai' | 'cohere' | 'huggingface' | 'local';
}

interface RestaurantData {
  menu: MenuItem[];
  tables: Table[];
  availability: {
    menuItems: string[];
    availableTables: number;
  };
}

interface MenuItem {
  _id: string;
  name: string;
  price: number;
  description?: string;
  category?: string;
  available: boolean;
  image?: string;
  hasImage?: boolean;
  imageUrl?: string;
}

interface Table {
  _id: string;
  tableNumber: string;
  capacity: number;
  location: string;
  status: string;
  zone?: string;
  features?: string[];
  isActive: boolean;
}

// Free AI APIs that actually work
const FREE_AI_APIS = [
  {
    name: 'groq',
    url: 'https://api.groq.com/openai/v1/chat/completions',
    model: 'llama-3.1-8b-instant',
    key: 'VITE_GROQ_API_KEY'
  },
  {
    name: 'cohere',
    url: 'https://api.cohere.ai/v1/generate',
    model: 'command-light',
    key: 'VITE_COHERE_API_KEY'
  },
  {
    name: 'openai',
    url: 'https://api.openai.com/v1/chat/completions',
    model: 'gpt-3.5-turbo',
    key: 'VITE_OPENAI_API_KEY'
  }
];

// Helper function to fetch all tables (handle pagination)
async function fetchAllTables(): Promise<Table[]> {
  try {
    console.log('üîç Fetching all tables with pagination handling...');
    
    // First, get the first page to know total pages
    const firstPageResponse = await fetch('http://localhost:5006/api/tables?page=1&limit=10');
    if (!firstPageResponse.ok) {
      console.error('‚ùå Failed to fetch first page of tables');
      return [];
    }
    
    const firstPageData = await firstPageResponse.json();
    console.log('üìÑ First page data:', firstPageData);
    
    if (!firstPageData.success || !firstPageData.data) {
      return [];
    }
    
    let allTables: Table[] = [...firstPageData.data.tables];
    const pagination = firstPageData.data.pagination;
    
    console.log(`üìä Pagination info: ${pagination.current}/${pagination.pages} pages, total: ${pagination.total}`);
    
    // If there are more pages, fetch them
    if (pagination.pages > 1) {
      for (let page = 2; page <= pagination.pages; page++) {
        const pageResponse = await fetch(`http://localhost:5006/api/tables?page=${page}&limit=10`);
        if (pageResponse.ok) {
          const pageData = await pageResponse.json();
          if (pageData.success && pageData.data.tables) {
            allTables = [...allTables, ...pageData.data.tables];
          }
        }
      }
    }
    
    console.log(`‚úÖ Fetched total ${allTables.length} tables from ${pagination.pages} pages`);
    return allTables;
    
  } catch (error) {
    console.error('‚ùå Error fetching all tables:', error);
    return [];
  }
}
async function testAPIEndpoint(url: string, name: string): Promise<unknown> {
  try {
    console.log(`üîç Testing ${name} API: ${url}`);
    const response = await fetch(url);
    
    if (!response.ok) {
      console.log(`‚ùå ${name} API returned status: ${response.status}`);
      return null;
    }
    
    const data = await response.json();
    console.log(`‚úÖ ${name} API response structure:`, typeof data, Array.isArray(data) ? 'Array' : 'Object');
    
    // Special debug for table API
    if (name === 'Table' && data && typeof data === 'object') {
      console.log(`üîç ${name} API full response:`, JSON.stringify(data, null, 2));
    }
    
    return data;
  } catch (error) {
    console.error(`‚ùå ${name} API error:`, error);
    return null;
  }
}

// Step 2: Fetch real data from database
async function fetchRestaurantData(): Promise<RestaurantData> {
  try {
    console.log('üìä Fetching restaurant data from database...');
    
    // Test and fetch menu data
    const rawMenuData = await testAPIEndpoint('http://localhost:5003/api/menu', 'Menu');
    let menuData: MenuItem[] = [];
    if (rawMenuData && Array.isArray(rawMenuData)) {
      menuData = rawMenuData;
    }
    
    // Test and fetch table data (v·ªõi pagination handling)
    const tableData: Table[] = await fetchAllTables();
    
    console.log('üìä Raw data:', { menuCount: menuData.length, tableCount: tableData.length });
    
    // Debug: Log all table data
    if (Array.isArray(tableData)) {
      console.log('üè¢ All tables data:', tableData.map(table => ({
        number: table.tableNumber,
        status: table.status,
        isActive: table.isActive,
        capacity: table.capacity
      })));
    }
    
    // Process availability with correct field names
    const availableMenuItems = Array.isArray(menuData) 
      ? menuData
          .filter((item: MenuItem) => item.available === true)
          .map((item: MenuItem) => `${item.name} - ${item.price.toLocaleString()}ƒë`)
      : [];
    
    const availableTables = Array.isArray(tableData)
      ? tableData.filter((table: Table) => {
          const isAvailable = table.status === 'available';
          const isActive = table.isActive;
          return isAvailable && isActive;
        }).length
      : 0;
    
    console.log(`üìä Table Summary: Total=${tableData.length}, Available=${availableTables}`);
    console.log(`‚úÖ Processed: ${availableMenuItems.length} available menu items, ${availableTables} available tables`);
    
    return {
      menu: menuData,
      tables: tableData,
      availability: {
        menuItems: availableMenuItems,
        availableTables
      }
    };
  } catch (error) {
    console.error('‚ùå Failed to fetch restaurant data:', error);
    return {
      menu: [],
      tables: [],
      availability: {
        menuItems: [],
        availableTables: 0
      }
    };
  }
}

export async function processQuestion(question: string): Promise<string> {
  console.log('ü§ñ Processing question:', question);
  
  // Step 1: Collect user question (already have it)
  
  // Step 2: Fetch real data from database
  const restaurantData = await fetchRestaurantData();
  
  // Step 3: Send question + real data to AI
  const apiResponse = await tryFreeAPIs(question, restaurantData);
  if (apiResponse) {
    return apiResponse;
  }
  
  // Step 4: Fallback to local AI with real data
  return getLocalAIResponse(question, restaurantData);
}

async function tryFreeAPIs(question: string, restaurantData: RestaurantData): Promise<string | null> {
  // Try each API in order
  for (const api of FREE_AI_APIS) {
    const apiKey = import.meta.env[api.key];
    if (!apiKey || apiKey === 'your_cohere_api_key_here' || apiKey === 'your_openai_api_key_here') {
      console.log(`${api.name} API key not found or placeholder, skipping...`);
      continue;
    }

    try {
      let response: string | null = null;
      
      switch (api.name) {
        case 'groq':
          response = await callGroqAPI(question, apiKey, restaurantData);
          break;
        case 'cohere':
          response = await callCohereAPI(question, apiKey, restaurantData);
          break;
        case 'openai':
          response = await callOpenAI(question, apiKey, restaurantData);
          break;
      }

      if (response) {
        console.log(`‚úÖ ${api.name} API responded successfully`);
        return response;
      }
    } catch (error) {
      console.log(`‚ùå ${api.name} API failed:`, error);
    }
  }

  return null;
}

async function callGroqAPI(question: string, apiKey: string, restaurantData: RestaurantData): Promise<string | null> {
  try {
    // Step 3: Create enhanced prompt with real data
    const menuInfo = restaurantData.availability.menuItems.length > 0 
      ? `MENU ƒê·∫¶Y ƒê·ª¶ (${restaurantData.availability.menuItems.length} m√≥n):\n${restaurantData.availability.menuItems.join('\n')}`
      : 'Menu ƒëang c·∫≠p nh·∫≠t';
    
    const totalTables = restaurantData.tables.length;
    const availableTables = restaurantData.availability.availableTables;
    const tableInfo = `TH√îNG TIN B√ÄN: ${availableTables}/${totalTables} b√†n tr·ªëng (${Math.round((availableTables/totalTables)*100)}% kh·∫£ d·ª•ng)`;
    
    const response = await fetch('https://api.groq.com/openai/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${apiKey}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: 'llama-3.1-8b-instant',
        messages: [
          {
            role: 'system',
            content: `B·∫°n l√† tr·ª£ l√Ω AI th√¥ng minh c·ªßa Nh√† H√†ng H·∫£i S·∫£n Bi·ªÉn ƒê√¥ng. 

Th√¥ng tin nh√† h√†ng:
- T√™n: Nh√† H√†ng H·∫£i S·∫£n Bi·ªÉn ƒê√¥ng  
- ƒê·ªãa ch·ªâ: 123 ƒê∆∞·ªùng H·∫£i S·∫£n, Qu·∫≠n Bi·ªÉn ƒê√¥ng, TP.HCM
- Hotline: 0936.253.588
- Gi·ªù m·ªü: 6:00-22:00 h√†ng ng√†y
- ƒê·∫∑c s·∫£n: H·∫£i s·∫£n t∆∞∆°i s·ªëng

TH√îNG TIN TH·ªúI GIAN TH·ª∞C T·ª™ DATABASE:
${menuInfo}

${tableInfo}

QUAN TR·ªåNG: 
- Khi h·ªèi v·ªÅ s·ªë l∆∞·ª£ng m√≥n, tr·∫£ l·ªùi ch√≠nh x√°c s·ªë m√≥n c√≥ s·∫µn
- Khi h·ªèi v·ªÅ b√†n, cung c·∫•p th√¥ng tin chi ti·∫øt v·ªÅ t·ª∑ l·ªá tr·ªëng/ƒë√£ ƒë·∫∑t
- Lu√¥n d·ª±a tr√™n d·ªØ li·ªáu th·ª±c t·∫ø t·ª´ database

H√£y tr·∫£ l·ªùi d·ª±a tr√™n th√¥ng tin th·ª±c t·∫ø n√†y, th√¢n thi·ªán v√† h·ªØu √≠ch v·ªõi emoji ph√π h·ª£p.`
          },
          {
            role: 'user',
            content: question
          }
        ],
        max_tokens: 400,
        temperature: 0.7
      })
    });

    if (response.ok) {
      const data = await response.json();
      return data.choices[0]?.message?.content?.trim() || null;
    } else {
      console.error('Groq API Error:', response.status, response.statusText);
      const errorData = await response.text();
      console.error('Error details:', errorData);
    }
  } catch (error) {
    console.error('Groq API Error:', error);
  }
  return null;
}

async function callCohereAPI(question: string, apiKey: string, restaurantData: RestaurantData): Promise<string | null> {
  try {
    const menuInfo = restaurantData.availability.menuItems.length > 0 
      ? `Menu: ${restaurantData.availability.menuItems.slice(0, 5).join(', ')}`
      : 'Menu ƒëang c·∫≠p nh·∫≠t';
    
    const response = await fetch('https://api.cohere.ai/v1/generate', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${apiKey}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: 'command-light',
        prompt: `B·∫°n l√† tr·ª£ l√Ω AI c·ªßa nh√† h√†ng H·∫£i S·∫£n Bi·ªÉn ƒê√¥ng. ${menuInfo}. B√†n tr·ªëng: ${restaurantData.availability.availableTables}. C√¢u h·ªèi: ${question}\nTr·∫£ l·ªùi:`,
        max_tokens: 200,
        temperature: 0.7,
        stop_sequences: ['\n\n']
      })
    });

    if (response.ok) {
      const data = await response.json();
      return data.generations[0]?.text?.trim() || null;
    }
  } catch (error) {
    console.error('Cohere API Error:', error);
  }
  return null;
}

async function callOpenAI(question: string, apiKey: string, restaurantData: RestaurantData): Promise<string | null> {
  try {
    const menuInfo = restaurantData.availability.menuItems.length > 0 
      ? `Menu hi·ªán c√≥: ${restaurantData.availability.menuItems.slice(0, 8).join(', ')}`
      : 'Menu ƒëang c·∫≠p nh·∫≠t';
      
    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${apiKey}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: 'gpt-3.5-turbo',
        messages: [
          {
            role: 'system',
            content: `B·∫°n l√† tr·ª£ l√Ω AI c·ªßa Nh√† H√†ng H·∫£i S·∫£n Bi·ªÉn ƒê√¥ng. ${menuInfo}. B√†n tr·ªëng: ${restaurantData.availability.availableTables}. Tr·∫£ l·ªùi th√¢n thi·ªán v√† h·ªØu √≠ch d·ª±a tr√™n th√¥ng tin th·ª±c t·∫ø.`
          },
          {
            role: 'user',
            content: question
          }
        ],
        max_tokens: 300,
        temperature: 0.7
      })
    });

    if (response.ok) {
      const data = await response.json();
      return data.choices[0]?.message?.content?.trim() || null;
    }
  } catch (error) {
    console.error('OpenAI API Error:', error);
  }
  return null;
}

// Step 4: Local AI response with real data as fallback
function getLocalAIResponse(question: string, restaurantData: RestaurantData): string {
  const lowerQuestion = question.toLowerCase();

  // Restaurant-specific responses with REAL DATA
  if (lowerQuestion.includes('menu') || lowerQuestion.includes('m√≥n ƒÉn') || lowerQuestion.includes('bao nhi√™u m√≥n')) {
    const menuItems = restaurantData.availability.menuItems;
    if (menuItems.length > 0) {
      return `üçΩÔ∏è **Menu Nh√† H√†ng H·∫£i S·∫£n Bi·ªÉn ƒê√¥ng** (Database th·ªùi gian th·ª±c)

üìä **T·ªïng c·ªông: ${menuItems.length} m√≥n c√≥ s·∫µn**

ü¶ê **Danh s√°ch ƒë·∫ßy ƒë·ªß:**
${menuItems.map((item, index) => `${index + 1}. ${item}`).join('\n')}

üí∞ **Gi√° t·ª´ th·∫•p ƒë·∫øn cao** | üìû **ƒê·∫∑t m√≥n: 0936.253.588**`;
    } else {
      return `üçΩÔ∏è **Menu ƒëang ƒë∆∞·ª£c c·∫≠p nh·∫≠t**

üìû **Vui l√≤ng g·ªçi**: 0936.253.588 ƒë·ªÉ bi·∫øt m√≥n ƒÉn hi·ªán c√≥
‚è∞ **Gi·ªù m·ªü**: 6:00-22:00 h√†ng ng√†y

**Xin l·ªói v√¨ s·ª± b·∫•t ti·ªán!**`;
    }
  }

  if (lowerQuestion.includes('ƒë·∫∑t b√†n') || lowerQuestion.includes('reservation') || lowerQuestion.includes('b√†n')) {
    const totalTables = restaurantData.tables.length;
    const availableTables = restaurantData.availability.availableTables;
    const occupiedTables = totalTables - availableTables;
    
    return `üìû **Th√¥ng tin ƒë·∫∑t b√†n** (Database th·ªùi gian th·ª±c)

üî• **Hotline**: 0936.253.588
üìä **T√¨nh tr·∫°ng b√†n hi·ªán t·∫°i**:
   ‚Ä¢ üü¢ B√†n tr·ªëng: ${availableTables}/${totalTables} b√†n
   ‚Ä¢ üî¥ B√†n ƒë√£ ƒë·∫∑t: ${occupiedTables} b√†n
   ‚Ä¢ üìà T·ª∑ l·ªá tr·ªëng: ${Math.round((availableTables/totalTables)*100)}%

‚è∞ **Gi·ªù nh·∫≠n ƒë·∫∑t**: 6:00 - 21:30

üí° **L∆∞u √Ω:**
‚Ä¢ ƒê·∫∑t tr∆∞·ªõc 30 ph√∫t cho b√†n th∆∞·ªùng
‚Ä¢ Cu·ªëi tu·∫ßn ƒë·∫∑t tr∆∞·ªõc 2-3 ti·∫øng
‚Ä¢ Nh√≥m >10 ng∆∞·ªùi ƒë·∫∑t tr∆∞·ªõc 1 ng√†y

üéâ **∆Øu ƒë√£i:** Nh√≥m >10 ng∆∞·ªùi gi·∫£m 10%`;
  }

  if (lowerQuestion.includes('ƒë·ªãa ch·ªâ') || lowerQuestion.includes('·ªü ƒë√¢u')) {
    return `üìç **Th√¥ng tin nh√† h√†ng**

üè† **ƒê·ªãa ch·ªâ**: 123 ƒê∆∞·ªùng H·∫£i S·∫£n, Qu·∫≠n Bi·ªÉn ƒê√¥ng, TP.HCM
üìû **ƒêi·ªán tho·∫°i**: 0936.253.588
‚è∞ **Gi·ªù m·ªü c·ª≠a**: 6:00 - 22:00 (7 ng√†y/tu·∫ßn)

üöó **Ti·ªán √≠ch**: B√£i ƒë·∫≠u xe mi·ªÖn ph√≠, giao h√†ng t·∫≠n n∆°i`;
  }

  // General AI responses
  if (lowerQuestion.includes('ch√†o') || lowerQuestion.includes('hello') || lowerQuestion.includes('hi')) {
    return `üëã **Ch√†o b·∫°n!** T√¥i l√† tr·ª£ l√Ω AI c·ªßa nh√† h√†ng H·∫£i S·∫£n Bi·ªÉn ƒê√¥ng.

ü§ñ T√¥i c√≥ th·ªÉ gi√∫p b·∫°n:
‚Ä¢ üçΩÔ∏è T∆∞ v·∫•n m√≥n ƒÉn v√† menu
‚Ä¢ üí∞ Th√¥ng tin gi√° c·∫£
‚Ä¢ üìç H∆∞·ªõng d·∫´n ƒë·ªãa ch·ªâ
‚Ä¢ ‚è∞ Gi·ªù m·ªü c·ª≠a v√† ƒë·∫∑t b√†n
‚Ä¢ üéØ G·ª£i √Ω m√≥n ƒë·∫∑c bi·ªát

**B·∫°n mu·ªën t√¨m hi·ªÉu ƒëi·ªÅu g√¨?**`;
  }

  if (lowerQuestion.includes('c·∫£m ∆°n') || lowerQuestion.includes('thank')) {
    return `üôè **R·∫•t vui ƒë∆∞·ª£c gi√∫p b·∫°n!**

N·∫øu c√≥ th√™m c√¢u h·ªèi n√†o v·ªÅ nh√† h√†ng, m√≥n ƒÉn, hay mu·ªën ƒë·∫∑t b√†n, ƒë·ª´ng ng·∫°i h·ªèi t√¥i nh√©!

üçΩÔ∏è Ch√∫c b·∫°n c√≥ nh·ªØng b·ªØa ƒÉn ngon mi·ªáng t·∫°i H·∫£i S·∫£n Bi·ªÉn ƒê√¥ng!`;
  }

  // Math calculations
  const mathMatch = question.match(/[\d+\-*/()^‚àö%.,\s]+/);
  if (mathMatch && /[+\-*/^‚àö%]/.test(question)) {
    try {
      let expr = question.replace(/\s/g, '').replace(/√ó/g, '*').replace(/√∑/g, '/');
      expr = expr.replace(/‚àö(\d+)/g, 'Math.sqrt($1)');
      expr = expr.replace(/(\d+)\^(\d+)/g, 'Math.pow($1,$2)');

      const result = Function(`"use strict"; return (${expr})`)();
      if (typeof result === 'number' && !isNaN(result)) {
        return `üßÆ **K·∫øt qu·∫£**: ${question} = **${result.toFixed(2)}**`;
      }
    } catch {
      // Continue to general response
    }
  }

  // Default intelligent responses
  const responses = [
    `ü§î **C√¢u h·ªèi th√∫ v·ªã!** T√¥i c√≥ th·ªÉ gi√∫p b·∫°n v·ªÅ:

üçΩÔ∏è **Nh√† h√†ng:**
‚Ä¢ Menu v√† gi√° c·∫£
‚Ä¢ ƒê·∫∑t b√†n, ƒë·ªãa ch·ªâ
‚Ä¢ Gi·ªù m·ªü c·ª≠a, ƒë·∫∑c s·∫£n

üßÆ **Kh√°c:**
‚Ä¢ T√≠nh to√°n c∆° b·∫£n
‚Ä¢ T∆∞ v·∫•n, h·ªó tr·ª£

**B·∫°n mu·ªën h·ªèi v·ªÅ ch·ªß ƒë·ªÅ n√†o?**`,

    `üí° **T√¥i s·∫µn s√†ng h·ªó tr·ª£!**

Hi·ªán t·∫°i t√¥i c√≥ th·ªÉ t∆∞ v·∫•n v·ªÅ:
‚Ä¢ üçΩÔ∏è **Menu**: M√≥n ƒÉn, gi√° c·∫£, g·ª£i √Ω
‚Ä¢ üìû **ƒê·∫∑t b√†n**: Hotline, gi·ªù nh·∫≠n ƒë·∫∑t
‚Ä¢ üìç **Th√¥ng tin**: ƒê·ªãa ch·ªâ, ti·ªán √≠ch
‚Ä¢ üßÆ **T√≠nh to√°n**: Ph√©p t√≠nh ƒë∆°n gi·∫£n

**B·∫°n c·∫ßn h·ªó tr·ª£ g√¨ c·ª• th·ªÉ?**`,

    `üéØ **H√£y cho t√¥i bi·∫øt b·∫°n c·∫ßn g√¨!**

T√¥i l√† tr·ª£ l√Ω c·ªßa nh√† h√†ng H·∫£i S·∫£n Bi·ªÉn ƒê√¥ng, c√≥ th·ªÉ:
‚Ä¢ T∆∞ v·∫•n **m√≥n ƒÉn ngon**
‚Ä¢ H·ªó tr·ª£ **ƒë·∫∑t b√†n**
‚Ä¢ Cung c·∫•p **th√¥ng tin nh√† h√†ng**
‚Ä¢ **T√≠nh to√°n** nhanh

**H·ªèi t√¥i b·∫•t c·ª© ƒëi·ªÅu g√¨ nh√©! üöÄ**`
  ];

  return responses[Math.floor(Math.random() * responses.length)];
}