import { chatbotCartTools } from './chatbotCartService';

export interface AIResponse {
  text: string;
  confidence?: number;
  source?: 'groq' | 'openai' | 'cohere' | 'huggingface' | 'local';
}

interface RestaurantData {
  menu: MenuItem[];
  tables: Table[];
  availability: {
    menuItems: string[];
    availableTables: number;
  };
}

interface MenuItem {
  _id: string;
  name: string;
  price: number;
  description?: string;
  category?: string;
  available: boolean;
  image?: string;
  hasImage?: boolean;
  imageUrl?: string;
}

interface Table {
  _id: string;
  tableNumber: string;
  capacity: number;
  location: string;
  status: string;
  zone?: string;
  features?: string[];
  isActive: boolean;
}

// Web Search API
const SERPER_API_KEY = import.meta.env.VITE_SERPER_API_KEY;

// Free AI APIs that actually work
const FREE_AI_APIS = [
  {
    name: 'groq',
    url: 'https://api.groq.com/openai/v1/chat/completions',
    model: 'llama-3.1-8b-instant',
    key: 'VITE_GROQ_API_KEY'
  },
  {
    name: 'cohere',
    url: 'https://api.cohere.ai/v1/generate',
    model: 'command-light',
    key: 'VITE_COHERE_API_KEY'
  },
  {
    name: 'openai',
    url: 'https://api.openai.com/v1/chat/completions',
    model: 'gpt-3.5-turbo',
    key: 'VITE_OPENAI_API_KEY'
  }
];

// Helper function to fetch all tables (handle pagination)
async function fetchAllTables(): Promise<Table[]> {
  try {
    console.log('üîç Fetching all tables with pagination handling...');
    
    // First, get the first page to know total pages
    const firstPageResponse = await fetch('http://localhost:5006/api/tables?page=1&limit=10');
    if (!firstPageResponse.ok) {
      console.error('‚ùå Failed to fetch first page of tables');
      return [];
    }
    
    const firstPageData = await firstPageResponse.json();
    console.log('üìÑ First page data:', firstPageData);
    
    if (!firstPageData.success || !firstPageData.data) {
      return [];
    }
    
    let allTables: Table[] = [...firstPageData.data.tables];
    const pagination = firstPageData.data.pagination;
    
    console.log(`üìä Pagination info: ${pagination.current}/${pagination.pages} pages, total: ${pagination.total}`);
    
    // If there are more pages, fetch them
    if (pagination.pages > 1) {
      for (let page = 2; page <= pagination.pages; page++) {
        const pageResponse = await fetch(`http://localhost:5006/api/tables?page=${page}&limit=10`);
        if (pageResponse.ok) {
          const pageData = await pageResponse.json();
          if (pageData.success && pageData.data.tables) {
            allTables = [...allTables, ...pageData.data.tables];
          }
        }
      }
    }
    
    console.log(`‚úÖ Fetched total ${allTables.length} tables from ${pagination.pages} pages`);
    return allTables;
    
  } catch (error) {
    console.error('‚ùå Error fetching all tables:', error);
    return [];
  }
}
async function testAPIEndpoint(url: string, name: string): Promise<unknown> {
  try {
    console.log(`üîç Testing ${name} API: ${url}`);
    const response = await fetch(url);
    
    if (!response.ok) {
      console.log(`‚ùå ${name} API returned status: ${response.status}`);
      return null;
    }
    
    const data = await response.json();
    console.log(`‚úÖ ${name} API response structure:`, typeof data, Array.isArray(data) ? 'Array' : 'Object');
    
    // Special debug for table API
    if (name === 'Table' && data && typeof data === 'object') {
      console.log(`üîç ${name} API full response:`, JSON.stringify(data, null, 2));
    }
    
    return data;
  } catch (error) {
    console.error(`‚ùå ${name} API error:`, error);
    return null;
  }
}

// Step 2: Fetch real data from database
async function fetchRestaurantData(): Promise<RestaurantData> {
  try {
    console.log('üìä Fetching restaurant data from database...');
    
    // Test and fetch menu data
    const rawMenuData = await testAPIEndpoint('http://localhost:5003/api/menu', 'Menu');
    let menuData: MenuItem[] = [];
    if (rawMenuData && Array.isArray(rawMenuData)) {
      menuData = rawMenuData;
    }
    
    // Test and fetch table data (v·ªõi pagination handling)
    const tableData: Table[] = await fetchAllTables();
    
    console.log('üìä Raw data:', { menuCount: menuData.length, tableCount: tableData.length });
    
    // Debug: Log all table data
    if (Array.isArray(tableData)) {
      console.log('üè¢ All tables data:', tableData.map(table => ({
        number: table.tableNumber,
        status: table.status,
        isActive: table.isActive,
        capacity: table.capacity
      })));
    }
    
    // Process availability with correct field names
    const availableMenuItems = Array.isArray(menuData) 
      ? menuData
          .filter((item: MenuItem) => item.available === true)
          .map((item: MenuItem) => `${item.name} - ${item.price.toLocaleString()}ƒë`)
      : [];
    
    const availableTables = Array.isArray(tableData)
      ? tableData.filter((table: Table) => {
          const isAvailable = table.status === 'available';
          const isActive = table.isActive;
          return isAvailable && isActive;
        }).length
      : 0;
    
    console.log(`üìä Table Summary: Total=${tableData.length}, Available=${availableTables}`);
    console.log(`‚úÖ Processed: ${availableMenuItems.length} available menu items, ${availableTables} available tables`);
    
    return {
      menu: menuData,
      tables: tableData,
      availability: {
        menuItems: availableMenuItems,
        availableTables
      }
    };
  } catch (error) {
    console.error('‚ùå Failed to fetch restaurant data:', error);
    return {
      menu: [],
      tables: [],
      availability: {
        menuItems: [],
        availableTables: 0
      }
    };
  }
}

export async function processQuestion(question: string): Promise<string> {
  console.log('ü§ñ Processing question:', question);
  
  // Step 1: Check if question is about cart operations
  const cartResponse = await handleCartOperations(question);
  if (cartResponse) {
    return cartResponse;
  }
  
  // Step 2: Fetch real data from database for menu questions
  const restaurantData = await fetchRestaurantData();
  
  // Step 3: Web search for general questions
  let webSearchResults: string | null = null;
  if (shouldSearchWeb(question)) {
    webSearchResults = await searchWeb(question);
  }
  
  // Step 4: Send question + real data + web search to AI
  const apiResponse = await tryFreeAPIs(question, restaurantData, webSearchResults || undefined);
  if (apiResponse) {
    return apiResponse;
  }
  
  // Step 5: Fallback to local AI with real data
  return getLocalAIResponse(question, restaurantData);
}

// New function to handle cart operations
async function handleCartOperations(question: string): Promise<string | null> {
  const lowerQuestion = question.toLowerCase();
  
  // 1. Th√™m m√≥n v√†o gi·ªè h√†ng
  if (
    (lowerQuestion.includes('th√™m') && !lowerQuestion.includes('th√™m nguy√™n li·ªáu')) ||
    (lowerQuestion.includes('ƒë·∫∑t') && !lowerQuestion.includes('ƒë·∫∑t b√†n')) ||
    lowerQuestion.includes('order') ||
    lowerQuestion.includes('mua')
  ) {
    return await handleAddToCart(question);
  }
  
  // 2. X√≥a to√†n b·ªô gi·ªè h√†ng (ki·ªÉm tra tr∆∞·ªõc ƒë·ªÉ tr√°nh xung ƒë·ªôt)
  if (
    (lowerQuestion.includes('x√≥a') || lowerQuestion.includes('xo√°') || lowerQuestion.includes('clear')) &&
    (lowerQuestion.includes('t·∫•t c·∫£') || lowerQuestion.includes('to√†n b·ªô') || lowerQuestion.includes('h·∫øt'))
  ) {
    const result = await chatbotCartTools.clearCart();
    return result.message;
  }
  
  // 3. X√≥a m√≥n kh·ªèi gi·ªè h√†ng (logic ƒë∆°n gi·∫£n h∆°n)
  if (
    lowerQuestion.includes('x√≥a') || lowerQuestion.includes('b·ªè') || 
    lowerQuestion.includes('h·ªßy') || lowerQuestion.includes('xo√°') ||
    lowerQuestion.includes('remove')
  ) {
    // Ki·ªÉm tra xem c√≥ ph·∫£i x√≥a b√†n/nguy√™n li·ªáu kh√¥ng
    if (!lowerQuestion.includes('b√†n') && !lowerQuestion.includes('nguy√™n li·ªáu')) {
      return await handleRemoveFromCart(question);
    }
  }
  
  // 4. Xem gi·ªè h√†ng
  if (lowerQuestion.includes('gi·ªè h√†ng') || lowerQuestion.includes('ƒë√£ ƒë·∫∑t')) {
    const result = await chatbotCartTools.getCartStatus();
    return result.message;
  }
  
  return null; // Kh√¥ng ph·∫£i c√¢u h·ªèi v·ªÅ gi·ªè h√†ng
}

// Handle adding items to cart
async function handleAddToCart(question: string): Promise<string> {
  try {
    // Extract dish name t·ª´ c√¢u h·ªèi
    const dishName = extractDishName(question);
    
    if (!dishName) {
      return 'ü§î B·∫°n mu·ªën th√™m m√≥n g√¨? Vui l√≤ng n√≥i r√µ t√™n m√≥n, v√≠ d·ª•: "Th√™m c∆°m chi√™n h·∫£i s·∫£n"';
    }
    
    // Extract quantity (m·∫∑c ƒë·ªãnh l√† 1)
    const quantity = extractQuantity(question);
    
    const result = await chatbotCartTools.addItemToCart(dishName, quantity);
    return result.message;
    
  } catch (error) {
    console.error('Handle add to cart error:', error);
    return 'C√≥ l·ªói khi th√™m m√≥n v√†o gi·ªè h√†ng. Vui l√≤ng th·ª≠ l·∫°i!';
  }
}

// Handle removing items from cart
async function handleRemoveFromCart(question: string): Promise<string> {
  try {
    // Extract dish name t·ª´ c√¢u h·ªèi
    const dishName = extractDishNameForRemoval(question);
    
    if (!dishName) {
      return 'ü§î B·∫°n mu·ªën x√≥a m√≥n g√¨ kh·ªèi gi·ªè h√†ng? Vui l√≤ng n√≥i r√µ t√™n m√≥n, v√≠ d·ª•: "X√≥a c∆°m chi√™n h·∫£i s·∫£n" ho·∫∑c "X√≥a 1 ph·∫ßn ph·ªü b√≤"';
    }
    
    // Extract quantity to remove (n·∫øu c√≥)
    const quantityToRemove = extractQuantityForRemoval(question);
    
    const result = await chatbotCartTools.removeItemFromCart(dishName, quantityToRemove);
    return result.message;
    
  } catch (error) {
    console.error('Handle remove from cart error:', error);
    return 'C√≥ l·ªói khi x√≥a m√≥n kh·ªèi gi·ªè h√†ng. Vui l√≤ng th·ª≠ l·∫°i!';
  }
}

// Utility functions to extract information from user input
function extractDishName(question: string): string {
  // Remove common words but keep numbers for quantity
  const cleaned = question.toLowerCase()
    .replace(/\b(th√™m|v√†o|gi·ªè|h√†ng|ƒë·∫∑t|m√≥n|order|mua|cho|t√¥i|em|anh|ch·ªã)\b/g, '')
    .replace(/\b(\d+)\s*(ph·∫ßn|su·∫•t|ƒëƒ©a|t√¥|ly|c√°i)\b/g, '') // Remove quantity expressions
    .trim();
  
  // If cleaned result is too short, try different approach
  if (cleaned.length < 3) {
    // Extract everything after "th√™m" or "ƒë·∫∑t"
    const afterThemMatch = question.toLowerCase().match(/(?:th√™m|ƒë·∫∑t|order|mua)\s+(.+?)(?:\s+v√†o|$)/);
    if (afterThemMatch) {
      return afterThemMatch[1]
        .replace(/\b(\d+)\s*(ph·∫ßn|su·∫•t|ƒëƒ©a|t√¥|ly|c√°i)\b/g, '')
        .trim();
    }
  }
  
  // Common dish patterns - expanded
  const patterns = [
    /ph·ªü\s+[a-zA-Z√Ä-·ªπ\s]+/,
    /c∆°m chi√™n [a-zA-Z√Ä-·ªπ\s]+/,
    /l·∫©u [a-zA-Z√Ä-·ªπ\s]+/,
    /[a-zA-Z√Ä-·ªπ\s]*h·∫£i s·∫£n[a-zA-Z√Ä-·ªπ\s]*/,
    /[a-zA-Z√Ä-·ªπ\s]*t√¥m[a-zA-Z√Ä-·ªπ\s]*/,
    /[a-zA-Z√Ä-·ªπ\s]*c√°[a-zA-Z√Ä-·ªπ\s]*/,
    /[a-zA-Z√Ä-·ªπ\s]*g√†[a-zA-Z√Ä-·ªπ\s]*/,
    /[a-zA-Z√Ä-·ªπ\s]*b√≤[a-zA-Z√Ä-·ªπ\s]*/,
  ];
  
  for (const pattern of patterns) {
    const match = cleaned.match(pattern);
    if (match) {
      return match[0].trim();
    }
  }
  
  // Fallback: take the remaining text if it's meaningful
  return cleaned.trim();
}

function extractQuantity(question: string): number {
  const match = question.match(/(\d+)\s*(ph·∫ßn|su·∫•t|ƒëƒ©a|t√¥|ly)?/);
  return match ? parseInt(match[1]) : 1;
}

function extractDishNameForRemoval(question: string): string {
  // Remove common words for removal
  const cleaned = question.toLowerCase()
    .replace(/\b(x√≥a|b·ªè|h·ªßy|xo√°|remove|delete|kh·ªèi|gi·ªè|h√†ng|m√≥n)\b/g, '')
    .replace(/\b(\d+)\s*(ph·∫ßn|su·∫•t|ƒëƒ©a|t√¥|ly|c√°i)\b/g, '') // Remove quantity expressions
    .trim();
  
  // If cleaned result is too short, try different approach
  if (cleaned.length < 3) {
    // Extract everything after "x√≥a" or "b·ªè"
    const afterRemoveMatch = question.toLowerCase().match(/(?:x√≥a|b·ªè|h·ªßy|xo√°)\s+(.+?)(?:\s+kh·ªèi|$)/);
    if (afterRemoveMatch) {
      return afterRemoveMatch[1]
        .replace(/\b(\d+)\s*(ph·∫ßn|su·∫•t|ƒëƒ©a|t√¥|ly|c√°i)\b/g, '')
        .replace(/\b(m√≥n|kh·ªèi|gi·ªè|h√†ng)\b/g, '')
        .trim();
    }
  }
  
  // Common dish patterns - same as add
  const patterns = [
    /ph·ªü\s+[a-zA-Z√Ä-·ªπ\s]+/,
    /c∆°m chi√™n [a-zA-Z√Ä-·ªπ\s]+/,
    /l·∫©u [a-zA-Z√Ä-·ªπ\s]+/,
    /[a-zA-Z√Ä-·ªπ\s]*h·∫£i s·∫£n[a-zA-Z√Ä-·ªπ\s]*/,
    /[a-zA-Z√Ä-·ªπ\s]*t√¥m[a-zA-Z√Ä-·ªπ\s]*/,
    /[a-zA-Z√Ä-·ªπ\s]*c√°[a-zA-Z√Ä-·ªπ\s]*/,
    /[a-zA-Z√Ä-·ªπ\s]*g√†[a-zA-Z√Ä-·ªπ\s]*/,
    /[a-zA-Z√Ä-·ªπ\s]*b√≤[a-zA-Z√Ä-·ªπ\s]*/,
  ];
  
  for (const pattern of patterns) {
    const match = cleaned.match(pattern);
    if (match) {
      return match[0].trim();
    }
  }
  
  // Fallback: take the remaining text if it's meaningful
  return cleaned.trim();
}

function extractQuantityForRemoval(question: string): number | undefined {
  // T√¨m pattern "x√≥a [s·ªë] [ƒë∆°n v·ªã]" ho·∫∑c "b·ªè [s·ªë] [ƒë∆°n v·ªã]"
  const patterns = [
    /(?:x√≥a|b·ªè|h·ªßy|xo√°|remove)\s+(\d+)\s*(?:ph·∫ßn|su·∫•t|ƒëƒ©a|t√¥|ly|c√°i)?/,
    /(\d+)\s*(?:ph·∫ßn|su·∫•t|ƒëƒ©a|t√¥|ly|c√°i)?\s+(?:x√≥a|b·ªè|h·ªßy|xo√°)/
  ];
  
  for (const pattern of patterns) {
    const match = question.toLowerCase().match(pattern);
    if (match) {
      const quantity = parseInt(match[1]);
      return quantity > 0 ? quantity : undefined;
    }
  }
  
  return undefined; // Kh√¥ng c√≥ s·ªë l∆∞·ª£ng c·ª• th·ªÉ = x√≥a to√†n b·ªô
}

async function tryFreeAPIs(question: string, restaurantData: RestaurantData, webSearchResults?: string): Promise<string | null> {
  // Try each API in order
  for (const api of FREE_AI_APIS) {
    const apiKey = import.meta.env[api.key];
    if (!apiKey || apiKey === 'your_cohere_api_key_here' || apiKey === 'your_openai_api_key_here') {
      console.log(`${api.name} API key not found or placeholder, skipping...`);
      continue;
    }

    try {
      let response: string | null = null;
      
      switch (api.name) {
        case 'groq':
          response = await callGroqAPI(question, apiKey, restaurantData, webSearchResults);
          break;
        case 'cohere':
          response = await callCohereAPI(question, apiKey, restaurantData);
          break;
        case 'openai':
          response = await callOpenAI(question, apiKey, restaurantData);
          break;
      }

      if (response) {
        console.log(`‚úÖ ${api.name} API responded successfully`);
        return response;
      }
    } catch (error) {
      console.log(`‚ùå ${api.name} API failed:`, error);
    }
  }

  return null;
}

// Check if question needs web search
function shouldSearchWeb(question: string): boolean {
  const lowerQuestion = question.toLowerCase();
  
  // Don't search for restaurant-specific questions
  const restaurantKeywords = [
    'menu', 'm√≥n ƒÉn', 'gi√°', 'b√†n', 'ƒë·∫∑t b√†n',
    'nh√† h√†ng', 'restaurant', 'h·∫£i s·∫£n',
    'gi·ªè h√†ng', 'cart', 'thanh to√°n',
    'order', 'ƒë∆°n h√†ng', 'm√≥n', 'th·ª©c ƒÉn',
    'table', 'b√†n ƒÉn', 'reservation', 'ƒë·∫∑t ch·ªó'
  ];
  
  // Check if it's a restaurant question
  const isRestaurantQuestion = restaurantKeywords.some(keyword => 
    lowerQuestion.includes(keyword)
  );
  
  if (isRestaurantQuestion) {
    return false;
  }
  
  // Search web for all other questions
  return true;
}

// Web Search API using Serper.dev
async function searchWeb(query: string): Promise<string | null> {
  if (!SERPER_API_KEY) {
    console.log('üîç Serper API key not found, skipping web search');
    return null;
  }

  try {
    console.log('üîç Searching web for:', query);
    
    const response = await fetch('https://google.serper.dev/search', {
      method: 'POST',
      headers: {
        'X-API-KEY': SERPER_API_KEY,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        q: query,
        num: 5, // L·∫•y 5 k·∫øt qu·∫£ ƒë·∫ßu ti√™n
        gl: 'vn', // Google Vietnam
        hl: 'vi' // Ti·∫øng Vi·ªát
      })
    });

    if (response.ok) {
      const data = await response.json();
      console.log('üîç Web search results:', data);
      
      // T·∫°o summary t·ª´ k·∫øt qu·∫£ t√¨m ki·∫øm
      let searchSummary = 'TH√îNG TIN T√åM KI·∫æM WEB:\n\n';
      
      if (data.organic && data.organic.length > 0) {
        data.organic.slice(0, 3).forEach((result: any, index: number) => {
          searchSummary += `${index + 1}. **${result.title}**\n`;
          searchSummary += `   ${result.snippet}\n`;
          searchSummary += `   Ngu·ªìn: ${result.link}\n\n`;
        });
      }
      
      if (data.knowledgeGraph) {
        searchSummary += `**TH√îNG TIN CHI TI·∫æT:**\n`;
        searchSummary += `${data.knowledgeGraph.description}\n`;
        searchSummary += `Ngu·ªìn: ${data.knowledgeGraph.descriptionSource}\n\n`;
      }
      
      return searchSummary;
    } else {
      console.error('üîç Serper API Error:', response.status, response.statusText);
    }
  } catch (error) {
    console.error('üîç Web search error:', error);
  }
  
  return null;
}

async function callGroqAPI(question: string, apiKey: string, restaurantData: RestaurantData, webSearchResults?: string): Promise<string | null> {
  try {
    // Step 3: Create enhanced prompt with real data
    const menuInfo = restaurantData.availability.menuItems.length > 0 
      ? `MENU ƒê·∫¶Y ƒê·ª¶ (${restaurantData.availability.menuItems.length} m√≥n):\n${restaurantData.availability.menuItems.join('\n')}`
      : 'Menu ƒëang c·∫≠p nh·∫≠t';
    
    const totalTables = restaurantData.tables.length;
    const availableTables = restaurantData.availability.availableTables;
    const tableInfo = `TH√îNG TIN B√ÄN: ${availableTables}/${totalTables} b√†n tr·ªëng (${Math.round((availableTables/totalTables)*100)}% kh·∫£ d·ª•ng)`;
    
    const response = await fetch('https://api.groq.com/openai/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${apiKey}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: 'llama-3.1-8b-instant',
        messages: [
          {
            role: 'system',
            content: `B·∫°n l√† tr·ª£ l√Ω AI th√¥ng minh c·ªßa Nh√† H√†ng H·∫£i S·∫£n Bi·ªÉn ƒê√¥ng. 

Th√¥ng tin nh√† h√†ng:
- T√™n: Nh√† H√†ng H·∫£i S·∫£n Bi·ªÉn ƒê√¥ng  
- ƒê·ªãa ch·ªâ: 123 ƒê∆∞·ªùng H·∫£i S·∫£n, Qu·∫≠n Bi·ªÉn ƒê√¥ng, TP.HCM
- Hotline: 0936.253.588
- Gi·ªù m·ªü: 6:00-22:00 h√†ng ng√†y
- ƒê·∫∑c s·∫£n: H·∫£i s·∫£n t∆∞∆°i s·ªëng

TH√îNG TIN TH·ª∞C T·∫æ T·ª™ DATABASE:
${menuInfo}

${tableInfo}${webSearchResults ? `\n\n${webSearchResults}` : ''}

QUAN TR·ªåNG: 
- Khi h·ªèi v·ªÅ s·ªë l∆∞·ª£ng m√≥n, tr·∫£ l·ªùi ch√≠nh x√°c s·ªë m√≥n c√≥ s·∫µn
- Khi h·ªèi v·ªÅ b√†n, cung c·∫•p th√¥ng tin chi ti·∫øt v·ªÅ t·ª∑ l·ªá tr·ªëng/ƒë√£ ƒë·∫∑t
- Lu√¥n d·ª±a tr√™n d·ªØ li·ªáu th·ª±c t·∫ø t·ª´ database
- Khi h·ªèi v·ªÅ th·ªùi gian, tr·∫£ l·ªùi theo m√∫i gi·ªù Vi·ªát Nam (GMT+7)
- S·ª≠ d·ª•ng th√¥ng tin web search ƒë·ªÉ b·ªï sung c√¢u tr·∫£ l·ªùi n·∫øu c·∫ßn

H√£y tr·∫£ l·ªùi d·ª±a tr√™n th√¥ng tin th·ª±c t·∫ø n√†y, th√¢n thi·ªán v√† h·ªØu √≠ch v·ªõi emoji ph√π h·ª£p.`
          },
          {
            role: 'user',
            content: question
          }
        ],
        max_tokens: 400,
        temperature: 0.7
      })
    });

    if (response.ok) {
      const data = await response.json();
      return data.choices[0]?.message?.content?.trim() || null;
    } else {
      console.error('Groq API Error:', response.status, response.statusText);
      const errorData = await response.text();
      console.error('Error details:', errorData);
    }
  } catch (error) {
    console.error('Groq API Error:', error);
  }
  return null;
}

async function callCohereAPI(question: string, apiKey: string, restaurantData: RestaurantData): Promise<string | null> {
  try {
    const menuInfo = restaurantData.availability.menuItems.length > 0 
      ? `Menu: ${restaurantData.availability.menuItems.slice(0, 5).join(', ')}`
      : 'Menu ƒëang c·∫≠p nh·∫≠t';
    
    const response = await fetch('https://api.cohere.ai/v1/generate', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${apiKey}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: 'command-light',
        prompt: `B·∫°n l√† tr·ª£ l√Ω AI c·ªßa nh√† h√†ng H·∫£i S·∫£n Bi·ªÉn ƒê√¥ng. ${menuInfo}. B√†n tr·ªëng: ${restaurantData.availability.availableTables}. C√¢u h·ªèi: ${question}\nTr·∫£ l·ªùi:`,
        max_tokens: 200,
        temperature: 0.7,
        stop_sequences: ['\n\n']
      })
    });

    if (response.ok) {
      const data = await response.json();
      return data.generations[0]?.text?.trim() || null;
    }
  } catch (error) {
    console.error('Cohere API Error:', error);
  }
  return null;
}

async function callOpenAI(question: string, apiKey: string, restaurantData: RestaurantData): Promise<string | null> {
  try {
    const menuInfo = restaurantData.availability.menuItems.length > 0 
      ? `Menu hi·ªán c√≥: ${restaurantData.availability.menuItems.slice(0, 8).join(', ')}`
      : 'Menu ƒëang c·∫≠p nh·∫≠t';
      
    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${apiKey}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: 'gpt-3.5-turbo',
        messages: [
          {
            role: 'system',
            content: `B·∫°n l√† tr·ª£ l√Ω AI c·ªßa Nh√† H√†ng H·∫£i S·∫£n Bi·ªÉn ƒê√¥ng. ${menuInfo}. B√†n tr·ªëng: ${restaurantData.availability.availableTables}. Tr·∫£ l·ªùi th√¢n thi·ªán v√† h·ªØu √≠ch d·ª±a tr√™n th√¥ng tin th·ª±c t·∫ø.`
          },
          {
            role: 'user',
            content: question
          }
        ],
        max_tokens: 300,
        temperature: 0.7
      })
    });

    if (response.ok) {
      const data = await response.json();
      return data.choices[0]?.message?.content?.trim() || null;
    }
  } catch (error) {
    console.error('OpenAI API Error:', error);
  }
  return null;
}

// Step 4: Local AI response with real data as fallback
function getLocalAIResponse(question: string, restaurantData: RestaurantData): string {
  const lowerQuestion = question.toLowerCase();

  // Restaurant-specific responses with REAL DATA
  if (lowerQuestion.includes('menu') || lowerQuestion.includes('m√≥n ƒÉn') || lowerQuestion.includes('bao nhi√™u m√≥n')) {
    const menuItems = restaurantData.availability.menuItems;
    if (menuItems.length > 0) {
      return `üçΩÔ∏è **Menu Nh√† H√†ng H·∫£i S·∫£n Bi·ªÉn ƒê√¥ng** (Database th·ªùi gian th·ª±c)

üìä **T·ªïng c·ªông: ${menuItems.length} m√≥n c√≥ s·∫µn**

ü¶ê **Danh s√°ch ƒë·∫ßy ƒë·ªß:**
${menuItems.map((item, index) => `${index + 1}. ${item}`).join('\n')}

üí∞ **Gi√° t·ª´ th·∫•p ƒë·∫øn cao** | üìû **ƒê·∫∑t m√≥n: 0936.253.588**`;
    } else {
      return `üçΩÔ∏è **Menu ƒëang ƒë∆∞·ª£c c·∫≠p nh·∫≠t**

üìû **Vui l√≤ng g·ªçi**: 0936.253.588 ƒë·ªÉ bi·∫øt m√≥n ƒÉn hi·ªán c√≥
‚è∞ **Gi·ªù m·ªü**: 6:00-22:00 h√†ng ng√†y

**Xin l·ªói v√¨ s·ª± b·∫•t ti·ªán!**`;
    }
  }

  if (lowerQuestion.includes('ƒë·∫∑t b√†n') || lowerQuestion.includes('reservation') || lowerQuestion.includes('b√†n')) {
    const totalTables = restaurantData.tables.length;
    const availableTables = restaurantData.availability.availableTables;
    const occupiedTables = totalTables - availableTables;
    
    return `üìû **Th√¥ng tin ƒë·∫∑t b√†n** (Database th·ªùi gian th·ª±c)

üî• **Hotline**: 0936.253.588
üìä **T√¨nh tr·∫°ng b√†n hi·ªán t·∫°i**:
   ‚Ä¢ üü¢ B√†n tr·ªëng: ${availableTables}/${totalTables} b√†n
   ‚Ä¢ üî¥ B√†n ƒë√£ ƒë·∫∑t: ${occupiedTables} b√†n
   ‚Ä¢ üìà T·ª∑ l·ªá tr·ªëng: ${Math.round((availableTables/totalTables)*100)}%

‚è∞ **Gi·ªù nh·∫≠n ƒë·∫∑t**: 6:00 - 21:30

üí° **L∆∞u √Ω:**
‚Ä¢ ƒê·∫∑t tr∆∞·ªõc 30 ph√∫t cho b√†n th∆∞·ªùng
‚Ä¢ Cu·ªëi tu·∫ßn ƒë·∫∑t tr∆∞·ªõc 2-3 ti·∫øng
‚Ä¢ Nh√≥m >10 ng∆∞·ªùi ƒë·∫∑t tr∆∞·ªõc 1 ng√†y

üéâ **∆Øu ƒë√£i:** Nh√≥m >10 ng∆∞·ªùi gi·∫£m 10%`;
  }

  if (lowerQuestion.includes('ƒë·ªãa ch·ªâ') || lowerQuestion.includes('·ªü ƒë√¢u')) {
    return `üìç **Th√¥ng tin nh√† h√†ng**

üè† **ƒê·ªãa ch·ªâ**: 123 ƒê∆∞·ªùng H·∫£i S·∫£n, Qu·∫≠n Bi·ªÉn ƒê√¥ng, TP.HCM
üìû **ƒêi·ªán tho·∫°i**: 0936.253.588
‚è∞ **Gi·ªù m·ªü c·ª≠a**: 6:00 - 22:00 (7 ng√†y/tu·∫ßn)

üöó **Ti·ªán √≠ch**: B√£i ƒë·∫≠u xe mi·ªÖn ph√≠, giao h√†ng t·∫≠n n∆°i`;
  }

  // General AI responses
  if (lowerQuestion.includes('ch√†o') || lowerQuestion.includes('hello') || lowerQuestion.includes('hi')) {
    return `üëã **Ch√†o b·∫°n!** T√¥i l√† tr·ª£ l√Ω AI c·ªßa nh√† h√†ng H·∫£i S·∫£n Bi·ªÉn ƒê√¥ng.

ü§ñ T√¥i c√≥ th·ªÉ gi√∫p b·∫°n:
‚Ä¢ üçΩÔ∏è T∆∞ v·∫•n m√≥n ƒÉn v√† menu
‚Ä¢ üí∞ Th√¥ng tin gi√° c·∫£
‚Ä¢ üìç H∆∞·ªõng d·∫´n ƒë·ªãa ch·ªâ
‚Ä¢ ‚è∞ Gi·ªù m·ªü c·ª≠a v√† ƒë·∫∑t b√†n
‚Ä¢ üéØ G·ª£i √Ω m√≥n ƒë·∫∑c bi·ªát

**B·∫°n mu·ªën t√¨m hi·ªÉu ƒëi·ªÅu g√¨?**`;
  }

  if (lowerQuestion.includes('c·∫£m ∆°n') || lowerQuestion.includes('thank')) {
    return `üôè **R·∫•t vui ƒë∆∞·ª£c gi√∫p b·∫°n!**

N·∫øu c√≥ th√™m c√¢u h·ªèi n√†o v·ªÅ nh√† h√†ng, m√≥n ƒÉn, hay mu·ªën ƒë·∫∑t b√†n, ƒë·ª´ng ng·∫°i h·ªèi t√¥i nh√©!

üçΩÔ∏è Ch√∫c b·∫°n c√≥ nh·ªØng b·ªØa ƒÉn ngon mi·ªáng t·∫°i H·∫£i S·∫£n Bi·ªÉn ƒê√¥ng!`;
  }

  // Math calculations
  const mathMatch = question.match(/[\d+\-*/()^‚àö%.,\s]+/);
  if (mathMatch && /[+\-*/^‚àö%]/.test(question)) {
    try {
      let expr = question.replace(/\s/g, '').replace(/√ó/g, '*').replace(/√∑/g, '/');
      expr = expr.replace(/‚àö(\d+)/g, 'Math.sqrt($1)');
      expr = expr.replace(/(\d+)\^(\d+)/g, 'Math.pow($1,$2)');

      const result = Function(`"use strict"; return (${expr})`)();
      if (typeof result === 'number' && !isNaN(result)) {
        return `üßÆ **K·∫øt qu·∫£**: ${question} = **${result.toFixed(2)}**`;
      }
    } catch {
      // Continue to general response
    }
  }

  // Default intelligent responses
  const responses = [
    `ü§î **C√¢u h·ªèi th√∫ v·ªã!** T√¥i c√≥ th·ªÉ gi√∫p b·∫°n v·ªÅ:

üçΩÔ∏è **Nh√† h√†ng:**
‚Ä¢ Menu v√† gi√° c·∫£
‚Ä¢ ƒê·∫∑t b√†n, ƒë·ªãa ch·ªâ
‚Ä¢ Gi·ªù m·ªü c·ª≠a, ƒë·∫∑c s·∫£n

üßÆ **Kh√°c:**
‚Ä¢ T√≠nh to√°n c∆° b·∫£n
‚Ä¢ T∆∞ v·∫•n, h·ªó tr·ª£

**B·∫°n mu·ªën h·ªèi v·ªÅ ch·ªß ƒë·ªÅ n√†o?**`,

    `üí° **T√¥i s·∫µn s√†ng h·ªó tr·ª£!**

Hi·ªán t·∫°i t√¥i c√≥ th·ªÉ t∆∞ v·∫•n v·ªÅ:
‚Ä¢ üçΩÔ∏è **Menu**: M√≥n ƒÉn, gi√° c·∫£, g·ª£i √Ω
‚Ä¢ üìû **ƒê·∫∑t b√†n**: Hotline, gi·ªù nh·∫≠n ƒë·∫∑t
‚Ä¢ üìç **Th√¥ng tin**: ƒê·ªãa ch·ªâ, ti·ªán √≠ch
‚Ä¢ üßÆ **T√≠nh to√°n**: Ph√©p t√≠nh ƒë∆°n gi·∫£n

**B·∫°n c·∫ßn h·ªó tr·ª£ g√¨ c·ª• th·ªÉ?**`,

    `üéØ **H√£y cho t√¥i bi·∫øt b·∫°n c·∫ßn g√¨!**

T√¥i l√† tr·ª£ l√Ω c·ªßa nh√† h√†ng H·∫£i S·∫£n Bi·ªÉn ƒê√¥ng, c√≥ th·ªÉ:
‚Ä¢ T∆∞ v·∫•n **m√≥n ƒÉn ngon**
‚Ä¢ H·ªó tr·ª£ **ƒë·∫∑t b√†n**
‚Ä¢ Cung c·∫•p **th√¥ng tin nh√† h√†ng**
‚Ä¢ **T√≠nh to√°n** nhanh

**H·ªèi t√¥i b·∫•t c·ª© ƒëi·ªÅu g√¨ nh√©! üöÄ**`
  ];

  return responses[Math.floor(Math.random() * responses.length)];
}